/*
 * generated by Xtext 2.12.0
 */
package nl.ru.sws.dsl.lighting.generator

import java.util.Collections
import nl.ru.sws.dsl.lighting.building.Building
import nl.ru.sws.dsl.lighting.building.Configuration
import nl.ru.sws.dsl.lighting.generator.cohla.ActorGenerator
import nl.ru.sws.dsl.lighting.generator.cohla.CoHLAGenerator
import nl.ru.sws.dsl.lighting.generator.cohla.DeviceGenerator
import nl.ru.sws.dsl.lighting.generator.cohla.InterfaceGenerator
import nl.ru.sws.dsl.lighting.generator.cohla.LoggerGenerator
import nl.ru.sws.dsl.lighting.generator.cohla.ORTIGenerator
import nl.ru.sws.dsl.lighting.generator.figure.SVGGenerator
import nl.ru.sws.dsl.lighting.generator.web.WebGenerator
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BuildingGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
	  val buildings = resource.allContents.filter(Building).toList
	  val config = resource.allContents.findLast[e | e instanceof Configuration] as Configuration
	  val nrOfActors = config.actors
	  val occupancySensorRanges = config.occupancySensorRanges
	  val hasLogger = config.hasLogger
	  val measureTime = config.measureTime
	  val hideSensorRange = config.hideSensorRange
	  val distributions = config.distributions ?: Collections.emptyList
	  val separateClasses = config.separateClasses
	  val separateActors = config.separateActors
	  val modelDir = config.modelDir
	  for (building : buildings) {
      val prefix = building.name.toFirstUpper + "/"
      fsa.generateFile(prefix + building.name + ".hla", CoHLAGenerator.generate(building, building.scenarios, nrOfActors, occupancySensorRanges, hasLogger, measureTime, distributions, separateClasses, separateActors))
      fsa.generateFile(prefix + 'Actor.hla', ActorGenerator.generate(nrOfActors, separateActors, building.areas.map[name]))
      if (hasLogger)
        fsa.generateFile(prefix + 'Logger.hla', LoggerGenerator.generate(measureTime, separateClasses, building.areas.map[name]))
      fsa.generateFile(prefix + 'FedClasses.hla', DeviceGenerator.generate(building, separateClasses, modelDir))
      fsa.generateFile(prefix + "interfaces.hla", InterfaceGenerator.generate(building, nrOfActors, separateClasses, separateActors))
      fsa.generateFile(prefix + 'orti.hla', ORTIGenerator.generate())
      for (occupancySensorRange : occupancySensorRanges)
        fsa.generateFile(prefix + building.name + "_" + occupancySensorRange + ".svg", SVGGenerator.generate(building, occupancySensorRange, hideSensorRange))
      WebGenerator.generate(fsa, building, occupancySensorRanges, hideSensorRange, nrOfActors)
   }
	}
}
